Модуль Spring Security позволяет нам внедрять права доступа, а также контролировать их исполнение без ручных проверок.
Spring Security базируется на 2х интерфейсах, которые определяют связь сущностей с секьюрностью: UserDetails и GrantedAuthority.
UserDetails — то, что будет интерпретироваться системой как пользователь.
GrantedAuthority — сущность, описывающая права юзера.
Оба эти интерфейса имеют множество реализаций: просмотрите класс WebSecurityConfig, в методе configure() с помощью настроек userDetailsService() мы собираем единственный на всю программу экземпляр UserDetails с именем и паролем user , а его роль “USER” так же будет преобразована в экземпляр GrantedAuthority.

Это простейший способ создания секьюрности. Так же мы можем использовать jdbc-аутентификацию путем написания запроса, возвращающего пользователя и роль.
Как вы понимаете, такие способы максимально просты, но лишены достаточной гибкости, потому наиболее часто используемый вариант настройки выглядит как имплементация UserDetails и GrantedAuthority в классах-сущностях с переопределением существующих методов.

Рассмотрим приложение.
Новые классы:
- WebSecurityConfig — настройка секьюрности по определенным URL, а также настройка UserDetails и GrantedAuthority.
- LoginSuccessHandler — хэндлер, содержащий в себе алгоритм действий при успешной аутентификации. Например, тут мы можем отправить пользователя с ролью админа на админку после логина, а с ролью юзер на главную страницу сайта и т.п.


Задание:


1. Перенесите классы и зависимости из предыдущей задачи.
2. Создайте класс Role и свяжите User с ролями так, чтобы юзер мог иметь несколько ролей.
3. Имплементируйте модели Role и User интерфейсами GrantedAuthority и UserDetails соответственно. Измените настройку секьюрности с inMemory на userDetailService.
4. Все CRUD-операции и страницы для них должны быть доступны только пользователю с ролью admin по url: /admin/.
5. Пользователь с ролью user должен иметь доступ только к своей домашней странице /user, где выводятся его данные. Доступ к этой странице должен быть только у пользователей с ролью user и admin. Не забывайте про несколько ролей у пользователя!
6. Настройте logout с любой страницы с использованием возможностей thymeleaf.
7. Настройте LoginSuccessHandler так, чтобы админа после аутентификации направляло на страницу /admin, а юзера на его страницу /user.

---

Для решения данной задачи рекомендуется использовать возможности ИИ, но не стоит просто полагаться на результат. Обязательно разберись в сгенерированном коде. Попроси ИИ объяснить, как работает каждая его часть и какие принципы лежат в основе. Это поможет тебе не только решить текущую задачу, но и укрепить свои знания и навыки программирования. 

Лично для меня одна из самых трудных задач на курсе. Но это пока..
Задача в целом весьма индивидуальная, т.е. можно добавлять разные столбцы, роли, странички и так далее. Распишу как я делал, абстрактно. Надеюсь поможет кому-то.

0) Клонируем задачку по ссылке и заставляем запуститься. Переносим зависимости с предыдущей задачи (Уже на этом этапе надо быть аккуратным, в силу того, что кому-то (как мне ) слой дао вообще может не понадобится). Как понять что вам понадобится ?
   https://www.youtube.com/watch?v=HvovW6Uh1yU&ab_channel=%D0%90%D0%BB%D0%B5%D0%BA%D1%81%D0%B0%D0%BD%D0%B4%D1%80%D0%A4%D0%B8%D1%81%D1%83%D0%BD%D0%BE%D0%B2
   Смотрим от начала и до конца. Сначала чтобы просто вникнуть в то, что от чего зависит. Может это не быстро, но уж точно очень полезно как для задачи, так и для общего понимания. Не пренебрегайте этим шагом

1) Теперь на основе вебинара на 2 часа делайте выводы какие файлы вам нужны, а какие нет. Переносим их в свою задачу.
   Сразу совет: Переносите по 1 пакету и запускайте. Запустилось и работает ? Круто - идем дальше. Если вы разом перенесете все подряд, то с ума сойдете искать ошибку.
   И сразу еще 1 совет: столбцы в таблицах у вас могут быть любые, однако на всякий случай сделайте их такого же названия как на примере, потому что иначе могут возникнуть совершенно не очевидные ошибки
   И еще 1 момент: крайне рекомендую ввести строчку
   spring.jpa.hibernate.ddl-auto=update
   Таблички будут сами создаваться на основе сущностей И ПРИ ЭТОМ создаваться дополнительные таблицы для связи сущностей. Вам никакой работы по таблицам даже делать не надо будет

2) В целом дальше можно просто по шагу делать то что говорится в задании + опираться на вебинар, поскольку вам ничего другого для решения этой задачи может и не понадобится.
   Сразу скажу, что в задаче ВАЖНО использовать
   JpaRepository<User, Long>
   JpaRepository<Role, Long>
   Поскольку они позволят соединять таблички по связи (в вебинаре это все есть )

3) После того как перенсены файлы и созданы сущности(которые создают нужные друг другу таблички), то может возникнуть необходимости в указании ролей
   https://www.codejava.net/frameworks/spring-boot/spring-thymeleaf-form-multi-checkboxes-mapping-with-collection-example
   Тут очень хорошо расписано

Еще может понадобится Алишев ( а именно платный по спринг буту ), но в целом тех сылок которые тут есть должно хватить. Разве что для дополнительного развития может помочь это
https://habr.com/ru/post/482552/

По итогу хочу дать только такие советы:
1) Делайте последовательно. Шаг за шагом. Не надо убегать вперед, потом просто будет столько ошибок, что замучаетесь их фиксить
2) Если вы дошли до этого шага, то эту технологию тоже освоите. Не волнуйтесь  